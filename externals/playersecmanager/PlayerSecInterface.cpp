/*
 * If not stated otherwise in this file or this component's license file the
 * following copyright and licenses apply:
 *
 * Copyright 2025 RDK Management
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

/**
 * @file PlayerSecInterface.cpp
 * @brief Interface for PlayerSec client
 */


#include "PlayerSecInterface.h"
#ifdef USE_SECCLIENT
#include "sec_client.h"
#endif

#ifdef USE_SECCLIENT
//Lookup table to convert secclient error to secmanager error
std::map<const int32_t, std::pair<const int32_t, const int32_t>> secClientSeManagerErrorLookUp =
{
	{SEC_CLIENT_RESULT_SUCCESS,                                {SECMANAGER_CLASS_RESULT_SUCCESS,        SECMANAGER_SUCCESS}},
	{SEC_CLIENT_RESULT_FAILURE,                                {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_INVALID_PARAMETERS,                     {SECMANAGER_CLASS_RESULT_SECCLIENT_FAIL, 0}},
	{SEC_CLIENT_RESULT_HTTP_RESULT_FAILURE_GENERIC,            {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_LICENSE_NETWORK_FAIL}},
	{SEC_CLIENT_RESULT_HTTP_RESULT_FAILURE_TOO_MANY_REDIRECTS, {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_LICENSE_NETWORK_FAIL}},
	{SEC_CLIENT_RESULT_HTTP_RESULT_FAILURE_CONNECTIVITY,       {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_LICENSE_NETWORK_FAIL}},
	{SEC_CLIENT_RESULT_HTTP_RESULT_FAILURE_HOST_RESOLUTION,    {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_LICENSE_NETWORK_FAIL}},
	{SEC_CLIENT_RESULT_HTTP_RESULT_FAILURE_TIMEOUT,            {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_LICENSE_NETWORK_FAIL}},
	{SEC_CLIENT_RESULT_HTTP_RESULT_FAILURE_TLS,                {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_LICENSE_NETWORK_FAIL}},
	{SEC_CLIENT_RESULT_MAC_AUTH_NOT_PROVISIONED,               {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_MAC_TOKEN_NO_PROV}},
	{SEC_CLIENT_RESULT_MONEYTRACE_MISSING_OR_MALFORMED,        {SECMANAGER_CLASS_RESULT_SECCLIENT_FAIL, 0}},
	{SEC_CLIENT_RESULT_REQUEST_CREATION_ERROR,                 {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_MALFORMED_RESPONSE_ERROR,               {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_MALFORMED_CONFIGURATION_PARAMETER_ERROR,{SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_MEMORY_ERROR,                           {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_MEMORY_ALLOCATION_ERROR}},
	{SEC_CLIENT_RESULT_FAILED_TO_LOAD_SEC_LIBRARY_ERROR,       {SECMANAGER_CLASS_RESULT_SECCLIENT_FAIL, 0}},
	{SEC_CLIENT_RESULT_INVALID_LOAD_CONFIGURATION_ERROR,       {SECMANAGER_CLASS_RESULT_SECCLIENT_FAIL, 0}},
	{SEC_CLIENT_RESULT_INVALID_LOAD_CRYPTO_TYPE_ERROR,         {SECMANAGER_CLASS_RESULT_SECCLIENT_FAIL, 0}},
	{SEC_CLIENT_RESULT_INVALID_LOAD_TIMEOUT_ERROR,             {SECMANAGER_CLASS_RESULT_SECCLIENT_FAIL, 0}},
	{SEC_CLIENT_RESULT_JSON_ENCODING_ERROR,                    {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_UNSUPPORTED_FEATURE,                    {SECMANAGER_CLASS_RESULT_SECCLIENT_FAIL, 0}},
	{SEC_CLIENT_RESULT_WATERMARKING_NOT_REQUIRED,              {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_WATERMARKING_SESSION_DENIED,            {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_GENERAL_CRYPTOGRAPHIC_ERROR,            {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_UNKNOWN_CRYPTO_ENGINE,                  {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_UNKNOWN_KEY_AGREEMENT_ALGO,             {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_INTERNAL_ERROR_EXPONENT,                {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_INTERNAL_ERROR_RANDOM,                  {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_UNSUPPORTED_HASH_ALGORITHM,             {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_ERROR_CREATING_MAC_AUTH_HEADER,         {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_ERROR_GENERATING_KEY_PAIR,              {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_ERROR_GENERATING_DERIVED_KEYS,          {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_ERROR_GENERATING_MAC_VALUE,             {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_CLIENT_VERIFICATION_ERROR,               {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_MISSING_SESSION_CREDENTIALS,            {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_ENCRYPTION_KEY_MISMATCH,                {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_PKCS7_SIGNATURE_ERROR,                  {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_UNDEFINED_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_CLIENT_AUTH_TOKEN_FAILURE,              {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_UNDEFINED_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_MISSING_KEY_PROVISIONING_DATA,          {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_UNDEFINED_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_MISSING_DEVICE_AUTH_DATA,               {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_UNDEFINED_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_INVALID_CONFIGURATION_PARAMETER,        {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_INVALID_DEVICE_TOKEN_PARAMETER,         {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_UNDEFINED_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_INVALID_KEY_PROVISION_RESULT_PARAMETER, {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_UNDEFINED_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_INVALID_DEVICE_AUTHENTICATION_RESULT_PARAMETER, {SECMANAGER_CLASS_RESULT_API_FAIL, SECMANAGER_REASON_API_UNDEFINED_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_INVALID_DEVICE_ATTRIBUTES_PARAMETER,    {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_UNDEFINED_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_INVALID_ACCESS_TOKEN_PARAMETER,         {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_INVALID_ACCESS_TOKEN}},
	{SEC_CLIENT_RESULT_INVALID_ACCESS_ATTRIBUTES_PARAMETER,    {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_INVALID_ACCESS_ATTRIBUTE}},
	{SEC_CLIENT_RESULT_INVALID_KEY_SYSTEM_PARAMETER,           {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_INVALID_KEY_SYSTEM_PARAM}},
	{SEC_CLIENT_RESULT_INVALID_LICENSE_REQUEST_PARAMETER,      {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_INVALID_DRM_LICENSE_PARAM}},
	{SEC_CLIENT_RESULT_INVALID_CONTENT_METADATA_PARAMETER,     {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_INVALID_CONTENT_METADATA}},
	{SEC_CLIENT_RESULT_INVALID_MEDIA_USAGE_PARAMETER,          {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_INVALID_MEDIA_USAGE}},
	{SEC_CLIENT_RESULT_INVALID_LICENSE_IDENTIFIER,             {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_UNDEFINED_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_INVALID_REQUEST_BODY,                   {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_ENTITLEMENT_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_INVALID_ACCOUNT_TOKEN_PARAMETER,        {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_UNDEFINED_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_INVALID_REQUEST_METADATA_PARAMETER,     {SECMANAGER_CLASS_RESULT_SECCLIENT_FAIL, 0}},
	{SEC_CLIENT_RESULT_INVALID_CONTENT_IDENTIFIER_PARAMETER,   {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_UNDEFINED_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_INVALID_DOWNLOADS_LIST_PARAMETER,       {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_UNDEFINED_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_INVALID_ACQUIRE_SAT_FUNCTION_PARAMETER, {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_UNDEFINED_ERROR}},  // Undefined
	{SEC_CLIENT_RESULT_INVALID_WATERMARKING_SYSTEM_PARAMETER,  {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_INVALID_WATERMARK_PARAMETER}},
	{SEC_CLIENT_RESULT_INVALID_CONTENT_ATTRIBUTES_PARAMETER,   {SECMANAGER_CLASS_RESULT_API_FAIL,       SECMANAGER_REASON_API_INVALID_CONTENT_PARAMETER}},
	{SEC_CLIENT_RESULT_UNSUPPORTED_OR_INVALID_WATERMARK_FEATURE, {SECMANAGER_CLASS_RESULT_DRM_FAIL,     SECMANAGER_REASON_DRM_GENERAL_FAILURE}},
	{SEC_CLIENT_RESULT_INVALID_WATERMARK_SESSION_RESPONSE,     {SECMANAGER_CLASS_RESULT_DRM_FAIL,       SECMANAGER_REASON_DRM_GENERAL_FAILURE}}
};
#endif

/**
 *	@brief Check if sec feature is enabled
 */
bool isSecFeatureEnabled() {
#if defined(USE_SECMANAGER) || defined(USE_SECCLIENT)
    return true;
#else
    return false;
#endif
}

/**
 * @brief Convert the secclient DRM error code into secmanager error code to have a unified verbose error reported
 */
bool getAsVerboseErrorCode(int32_t httpCode, int32_t &secManagerClass, int32_t &secManagerReasonCode )
{
#ifdef USE_SECCLIENT
	//look for the correct code from the lookup
	auto it = secClientSeManagerErrorLookUp.find(-httpCode); //Secclient error codes are -ve
	if (it != secClientSeManagerErrorLookUp.end()) {
		secManagerClass = it->second.first;
		secManagerReasonCode = it->second.second;
		return true;
	}
#endif
	return false;
}

/**
 *	@brief Acquire license via sec client
 */
int32_t PlayerSecInterface::PlayerSec_AcquireLicense(const char *serviceHostUrl, uint8_t numberOfRequestMetadataKeys,
									const char *requestMetadata[][2], uint8_t numberOfAccessAttributes,
									const char *accessAttributes[][2], const char *contentMetadata,
									size_t contentMetadataLength, const char *licenseRequest,
									size_t licenseRequestLength, const char *keySystemId,
									const char *mediaUsage, const char *accessToken,
									char **licenseResponse, size_t *licenseResponseLength,
									uint32_t *refreshDurationSeconds,
									PlayerSecExtendedStatus *statusInfo)
{
#ifdef USE_SECCLIENT
	int32_t sec_client_result = SEC_CLIENT_RESULT_FAILURE;
	SecClient_ExtendedStatus statusExtInfo = {};
	sec_client_result = SecClient_AcquireLicense(serviceHostUrl, numberOfRequestMetadataKeys,
													requestMetadata, numberOfAccessAttributes,
													accessAttributes,
													contentMetadata,
													contentMetadataLength,
													licenseRequest, licenseRequestLength, keySystemId, mediaUsage,
													accessToken,
													licenseResponse, licenseResponseLength, refreshDurationSeconds, &statusExtInfo);
	if (statusInfo != nullptr) {
		statusInfo->accessAttributeStatus = statusExtInfo.accessAttributeStatus;
		statusInfo->statusCode = statusExtInfo.statusCode;
	}
	return sec_client_result;
#else
	return 0;
#endif
}

/**
 *	@brief Free resource
 */
int32_t PlayerSecInterface::PlayerSec_FreeResource(const char *resource)
{
#ifdef USE_SECCLIENT
	int32_t sec_client_result = SEC_CLIENT_RESULT_FAILURE;
	if (resource)
	{
		sec_client_result = SecClient_FreeResource(resource);
	}
	return sec_client_result;
#else
	return 0;
#endif
}

/**
 *	@brief Check if sec request failed
 */
bool PlayerSecInterface::isSecRequestFailed(int32_t requestResult)
{
	bool isRequestFailed = 0;
#ifdef USE_SECCLIENT
	isRequestFailed = (requestResult != SEC_CLIENT_RESULT_SUCCESS);
#endif
	return isRequestFailed;
}

/**
 *	@brief Check if sec request result is in range
 */
bool PlayerSecInterface::isSecResultInRange(int32_t requestResult)
{
	bool isRequestInRange = 0;
#ifdef USE_SECCLIENT
	isRequestInRange = (requestResult >= SEC_CLIENT_RESULT_HTTP_RESULT_FAILURE_TLS  && requestResult <= SEC_CLIENT_RESULT_HTTP_RESULT_FAILURE_GENERIC );
#endif
	return isRequestInRange;
}
